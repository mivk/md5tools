#!/bin/bash

# Do md5 files for all subdirectories

ver=0.1.9
me=$(basename "$0")

set -o pipefail # keep errors from pipes

#### DEFAULTS

# Without the .md5 extension, which will be added automatically
md5_filename=checksums


#### FUNCTIONS

usage() {
        cat <<EOF

    Usage: $me [options] DIRECTORY

    Options:
        -f Filename : Filename for checksums (without extension. eg. "-f cs-md5". Default: $md5_filename)
        -n          : No action (dry_run). Don't actually calculate md5
        -d          : Debug (can be repeated)
        -V          : show version and exit
        -h          : This help

EOF
}

die() {
    echo "$@" 1>&2
    exit 1;
}

warn() {
    er="$@"
    echo "$er" 1>&2
    errors+=("$er")
}


confirm() {
    while true; do
        read -p "$* [y/n]: " yn
        case $yn in
            [Yy]*) return 0  ;;
            [Nn]*) echo "Aborted" ; return 1 ;;
        esac
    done
}


#### PARSE ARGUMENTS
#fixme: add verbose option

while getopts "df:nVh" opt; do
    case $opt in
        d) (( debug+=1 ));;
        f) md5_filename=$OPTARG;;
        n) dry_run=1;;
        V) echo "$0 version $ver"; exit;;
        h) usage; exit;;
    esac
done
shift $((OPTIND -1))

dir="$1"

if [ -z "$dir" ]; then
    usage
    die "Error: missing folder argument. Specify folder to process."
fi


#### OTHER INIT

(( debug )) && echo "$0 version $ver"

md5_filename="${md5_filename%%.md5}.md5"

(( debug )) && echo "md5_filename = $md5_filename"

# Check OS to select md5 command
if [[ "$OSTYPE" == "linux-gnu"* ]]; then
    is_linux=1
    md5cmd="md5sum"
    size_opts="-c %s"
elif [[ "$OSTYPE" == "darwin"* ]]; then
    is_mac=1
    md5cmd="md5 -r"
    size_opts="-f %z"
else
    die "Error: unknown OS '$OSTYPE'. Don't know correct md5 command."
fi
(( debug )) && echo "DEBUG: md5 command set to '$md5cmd'"


#### START

total_size=0
total_files=0

start_time=$(date "+%F_%T")

(( debug )) && echo "DEBUG: dir='$dir'" >&2

# go to base directory after saving where we started
start_dir="$PWD"
cd "$dir"
(( debug )) && echo "DEBUG: cd to '$dir'" >&2

# if we're in a symlink cd to the real path
if [ ! "$dir" = "$(pwd -P)" ]; then
    dir="$(pwd -P)"
    (( debug )) && echo "DEBUG: \$dir changed to real path '$dir'" >&2
    cd "$dir"
    (( debug )) && echo "DEBUG: Now in '$PWD'" >&2
fi

if [ "$PWD" = "/" ]; then
    die "Refusing to do it on system root '$PWD'"
fi


# Find all folders to process

declare -a subdirs=()
declare -a skipped=()
declare -a dcpdirs=()
declare -a wanted=()

# 1. find all non-hidden subdirectories (not if the name begins with "." like ".Trashes", ".Spotlight-V100", etc.)
#while read d; do subdirs+=("$d"); done < <(find . -type d -not -name ".*" | LC_ALL=C sort)
while IFS= read -r; do subdirs+=("$REPLY"); done < <(find . -type d -not -name ".*" | LC_ALL=C sort)
(( debug > 1 )) && printf "DEBUG: subdirs: %s\n" "${subdirs[@]}"

# 2. find DCP dirs to be excluded
if (( is_mac )); then
    while IFS= read -r; do dcpdirs+=("$REPLY"); done < <(find -E . -type f                           -regex ".*/ASSETMAP(\.xml)?" -execdir sh -c 'echo $PWD' \; | LC_ALL=C sort)
elif (( is_linux )); then
    while IFS= read -r; do dcpdirs+=("$REPLY"); done < <(find    . -type f -regextype posix-extended -regex ".*/ASSETMAP(\.xml)?" -printf "%h\n"                | LC_ALL=C sort)
fi
(( debug )) && printf "DEBUG: dcpdirs: %s\n" "${dcpdirs[@]}"

# 3. count files and if there are any, add dir to wanted, and calculate size
echo "Counting files and sizes to process ..."
for d in "$dir" "${subdirs[@]}"; do  # include "$dir" itself, not only it's subdirs

    (( debug > 1)) && echo "DEBUG: checking dir '$d'"

    # skip if it's a DCP
    isdcp=0
    for dcp in "${dcpdirs[@]}"; do
		(( debug )) && echo "DEBUG: Is '$dcp' a DCP dir?"
        if [[ "$d" =~ ^"$dcp"* ]]; then
            echo "Skipping DCP dir '$d'."
            skipped+=("$d")
            isdcp=1
            break
        fi
    done;
    (( isdcp )) && continue

    found_md5="$(find "$d" -maxdepth 1 -name "$md5_filename" -print -quit)"
    if [ -n "$found_md5" ]; then
		#fixme: warning not shown??
        echo "Skipping '$d'. It already has '$found_md5'"
        skipped+=("$d")
        continue
    fi


    files_here=0
    while IFS= read -r ; do
        (( total_files += 1 ))
        (( files_here  += 1 ))
        size=$(stat $size_opts "$REPLY")
        (( total_size += size ))
    done < <(find "$d" -maxdepth 1 -type f -not -name ".DS_Store" -not -name "._*" -not -name "*.md5")

    (( files_here )) && wanted+=("$d")

done

total_size_mb=$(( total_size / 1000000 ))

echo "Found ${#wanted[@]} folders to process:"
printf "  * %s\n" "${wanted[@]}"

if [ "${#skipped[@]}" -gt 0 ]; then
    echo "Skipping ${#skipped[@]} folder(s) :"
    printf "  * %s\n" "${skipped[@]}"
fi

if [ "${#wanted[*]}" = 0 ]; then
    echo "Nothing to do. Aborting."
    exit 0
fi


echo "total size = $total_size Bytes ($total_size_mb MB.)"

# Do you want to start?
confirm "Start processing $total_size_mb MB." || { cd "$start_dir"; exit 0; }

for d in "${wanted[@]}"; do
    if [ -f "$dir/$d/$md5_filename" ]; then
        # fixme: remove this part?
        echo "$d/$md5_filename file exists already. skipping"
        echo "This should have been seen before and is useless?"
        exit
        # ? DONE? fixme: add to list of skipped files
        continue
    fi

    echo "== Writing $dir/$d/$md5_filename"
    (( debug )) && echo "DEBUG: PWD=$PWD, cd to '$dir/$d'"

    cd "$dir/$d"
    find . -maxdepth 1 -type f -not -name "$md5_filename" -not -name '.DS_Store' -not -name "._*" \
    | LC_ALL=C sort \
    | while read f; do
        if (( dry_run )); then
            (( debug )) && echo "DEBUG: (-n) would do: $md5cmd \"$f\" | tee -a \"$md5_filename\""
            continue
        fi
        $md5cmd "$f" | tee -a "$md5_filename"
        rv=$?
        warn "ERROR $? with '$md5cmd \"$f\" | tee -a \"$md5_filename\"'"
      done
    echo
    cd "$dir"
done


end_time=$(date "+%F_%T")

echo "Done."
echo "Started at  $start_time"
echo "Finished at $end_time"
cd "$start_dir"

if (( ${#errors[@]} )); then
	echo "WARNING: There were errors:"
	printf "* %s\n" "${errors[@]}"
fi
